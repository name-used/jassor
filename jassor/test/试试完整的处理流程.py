"""
需要三步走：
1. 轮廓自相交规范化（复杂过程，参考 ChatGPT 代码）
2. 内外轮廓相交规范化（可以用 buffer(0)，前提是轮廓自相交已经消除）
3. 多轮廓相交规范化（可以用 unary_union）
"""
import shapely
import jassor.utils as J
from test_coords_func import normalize_single_ring
from shapely.ops import unary_union, polygonize


def main():
    # for coords in single_coords:
    #     coords_group = normalize_single_ring(coords)
    #     multi_poly = shapely.MultiPolygon(polygons=[shapely.Polygon(shell=coords, holes=[]) for coords in coords_group])
    #     multi_poly = unary_union(multi_poly)
    #     print(multi_poly.is_valid)
    #     J.plot(multi_poly)

    for item in polygon_coords:
        outer = item['outer']
        inners = item['inners']
        outer_group = normalize_single_ring(outer)
        inners_groups = [normalize_single_ring(inner) for inner in inners]
        inners_group = sum(inners_groups, [])
        # inners_group = unary_union(shapely.MultiPolygon(polygons=[shapely.Polygon(shell=inner, holes=[]) for inner in inners_group]))
        polygons = [shapely.Polygon(shell=outer, holes=inners_group).buffer(0) for outer in outer_group]
        multi_poly = unary_union(polygons)
        multi_poly = multi_poly.buffer(0)
        print(multi_poly.is_valid)
        J.plot(multi_poly)


single_coords = [
    # 典型蝴蝶结自交（八字歧义）✅必自交
    [(0, 0), (10, 10), (0, 10), (10, 0), (0, 0)],

    # 五角星（Pentagram）✅必自交
    # 取正五边形顶点，按“隔一个连一个”的顺序走：0->2->4->1->3->0
    [(0.00, 10.00), (5.88, -8.09), (-9.51, 3.09), (9.51, 3.09), (-5.88, -8.09), (0.00, 10.00)],

    # 多次自交的“花瓣环”✅多处交叉（比五角星更容易测试拆分/碎片）
    # 这是一个手工构造的自交 ring，交叉点>1
    [(0.0, 10.0), (-3.420201, -9.396926), (6.427876, 7.660444), (-8.660254, -5.0), (9.848078, 1.736482), (-9.848078, 1.736482), (8.660254, -5.0), (-6.427876, 7.660444), (3.420201, -9.396926), (0.0, 10.0)],

    # 所有点共线（面积=0）✅退化
    [(0, 0), (5, 0), (10, 0), (0, 0)],

    # 极瘦近似共线（数值不稳定/可能被认为退化）✅
    [(0, 0), (1000, 0), (1000, 1e-9), (0, 1e-9), (0, 0)],

    # 几乎在同一点“交叉”（浮点误差敏感）✅
    [(0, 0), (10, 10), (0, 10), (10, 0.0000001), (0, 0)],
]

polygon_coords = [
    # # 内轮廓越界（outer 已闭合 ✅）
    # dict(
    #     outer=[(1, 1), (10, 1), (10, 10), (1, 10), (1, 1)],
    #     inners=[[(8, 8), (11, 8), (9, 9), (8, 8)]],
    # ),
    #
    # # 内轮廓擦边（touch shell，outer 已闭合 ✅）
    # dict(
    #     outer=[(1, 1), (10, 1), (10, 10), (1, 10), (1, 1)],
    #     inners=[[(8, 8), (10, 8), (9, 9), (8, 8)]],
    # ),
    #
    # # 内轮廓交叉（outer 原来没闭合，这里修正 ✅）
    # dict(
    #     outer=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
    #     inners=[
    #         [(4, 4), (4, 9), (9, 9), (4, 4)],
    #         [(6, 6), (6, 1), (1, 1), (6, 6)],
    #     ],
    # ),
    #
    # # 内轮廓覆盖（outer 原来没闭合，这里修正 ✅）
    # dict(
    #     outer=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
    #     inners=[
    #         [(1, 1), (1, 9), (9, 9), (1, 1)],
    #         [(4, 4), (4, 6), (6, 6), (4, 4)],
    #     ],
    # ),
    # # 外轮廓=蝴蝶结自交，拆成两瓣；两瓣各自有 hole
    # dict(
    #     outer=[(0, 0), (10, 10), (0, 10), (10, 0), (0, 0)],   # bow-tie self-cross
    #     inners=[
    #         # hole in left-top triangle (0,0)-(10,10)-(0,10)
    #         [(1.0, 8.5), (2.0, 7.0), (3.0, 9.0), (1.0, 8.5)],
    #         # hole in right-bottom triangle (0,0)-(10,0)-(10,10)
    #         [(8.5, 1.0), (9.2, 2.2), (7.8, 2.5), (8.5, 1.0)],
    #     ],
    # ),
    # # 外轮廓=五角星自交；洞分别放在不同“臂区”附近（会产生多 part）
    # dict(
    #     outer=[(0.0, 10.0), (5.88, -8.09), (-9.51, 3.09), (9.51, 3.09), (-5.88, -8.09), (0.0, 10.0)],
    #     inners=[
    #         [(0.0, 6.5), (0.8, 5.5), (-0.8, 5.5), (0.0, 6.5)],
    #         [(5.5, 1.5), (6.2, 0.3), (4.8, 0.3), (5.5, 1.5)],
    #         [(-5.5, 1.5), (-4.8, 0.3), (-6.2, 0.3), (-5.5, 1.5)],
    #     ],
    # ),
    # # 外轮廓正常，但 inner 自交（洞本身是 bow-tie）✅（测你 inner 也要走 normalize）
    # dict(
    #     outer=[(0, 0), (12, 0), (12, 12), (0, 12), (0, 0)],
    #     inners=[
    #         [(3, 3), (9, 9), (3, 9), (9, 3), (3, 3)],  # bow-tie hole
    #     ],
    # ),
    # # 外轮廓正常，但 inner 穿出 outer（洞越界）✅（测 step2 的 buffer(0)）
    # dict(
    #     outer=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
    #     inners=[
    #         [(8, 8), (12, 8), (10, 11), (8, 8)],  # partly outside
    #     ],
    # ),
    #
    # # 外轮廓自交拆成两瓣，但 某个洞跨越两瓣（最容易“修坏语义”的）✅
    # dict(
    #     outer=[(0, 0), (10, 10), (0, 10), (10, 0), (0, 0)],  # bow-tie
    #     inners=[
    #         [(4.5, 4.5), (5.5, 4.5), (5.5, 5.5), (4.5, 5.5), (4.5, 4.5)],  # centered near intersection
    #     ],
    # ),
    # dict(
    #     outer=[(0, 0), (20, 0), (20, 20), (0, 20), (0, 0)],
    #     inners=[
    #         # 这条洞横贯整个外壳，等价于“切割带”，会把面分成上下两块
    #         [( -1, 9), (21, 9), (21, 11), (-1, 11), (-1, 9)],
    #     ],
    # ),
    dict(
        outer=[(0, 0), (20, 0), (20, 20), (0, 20), (0, 0)],
        inners=[
            # 这条洞横贯整个外壳，等价于“切割带”，会把面分成上下两块
            [(-1, -1), (21, -1), (21, 21), (-1, 21), (-1, -1)],
        ],
    ),
]

if __name__ == '__main__':
    main()



"""

SINGLE_SIMPLE_CASES = [
    # 典型蝴蝶结自交（八字歧义）✅必自交
    [(0, 0), (10, 10), (0, 10), (10, 0), (0, 0)],

    # 五角星（Pentagram）✅必自交
    # 取正五边形顶点，按“隔一个连一个”的顺序走：0->2->4->1->3->0
    [(0.00, 10.00), (5.88, -8.09), (-9.51, 3.09), (9.51, 3.09), (-5.88, -8.09), (0.00, 10.00)],

    # 多次自交的“花瓣环”✅多处交叉（比五角星更容易测试拆分/碎片）
    # 这是一个手工构造的自交 ring，交叉点>1
    [(0.0, 10.0), (-3.420201, -9.396926), (6.427876, 7.660444), (-8.660254, -5.0), (9.848078, 1.736482), (-9.848078, 1.736482), (8.660254, -5.0), (-6.427876, 7.660444), (3.420201, -9.396926), (0.0, 10.0)],

    # 所有点共线（面积=0）✅退化
    [(0, 0), (5, 0), (10, 0), (0, 0)],

    # 极瘦近似共线（数值不稳定/可能被认为退化）✅
    [(0, 0), (1000, 0), (1000, 1e-9), (0, 1e-9), (0, 0)],

    # 几乎在同一点“交叉”（浮点误差敏感）✅
    [(0, 0), (10, 10), (0, 10), (10, 0.0000001), (0, 0)],
]

SINGLE_COMPLEX_CASES = [
    # 内轮廓越界（outer 已闭合 ✅）
    dict(
        outer=[(1, 1), (10, 1), (10, 10), (1, 10), (1, 1)],
        inners=[[(8, 8), (11, 8), (9, 9), (8, 8)]],
    ),

    # 内轮廓擦边（touch shell，outer 已闭合 ✅）
    dict(
        outer=[(1, 1), (10, 1), (10, 10), (1, 10), (1, 1)],
        inners=[[(8, 8), (10, 8), (9, 9), (8, 8)]],
    ),

    # 内轮廓交叉（outer 原来没闭合，这里修正 ✅）
    dict(
        outer=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
        inners=[
            [(4, 4), (4, 9), (9, 9), (4, 4)],
            [(6, 6), (6, 1), (1, 1), (6, 6)],
        ],
    ),

    # 内轮廓覆盖（outer 原来没闭合，这里修正 ✅）
    dict(
        outer=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
        inners=[
            [(1, 1), (1, 9), (9, 9), (1, 1)],
            [(4, 4), (4, 6), (6, 6), (4, 4)],
        ],
    ),
    # 外轮廓=蝴蝶结自交，拆成两瓣；两瓣各自有 hole
    dict(
        outer=[(0, 0), (10, 10), (0, 10), (10, 0), (0, 0)],   # bow-tie self-cross
        inners=[
            # hole in left-top triangle (0,0)-(10,10)-(0,10)
            [(1.0, 8.5), (2.0, 7.0), (3.0, 9.0), (1.0, 8.5)],
            # hole in right-bottom triangle (0,0)-(10,0)-(10,10)
            [(8.5, 1.0), (9.2, 2.2), (7.8, 2.5), (8.5, 1.0)],
        ],
    ),
    # 外轮廓=五角星自交；洞分别放在不同“臂区”附近（会产生多 part）
    dict(
        outer=[(0.0, 10.0), (5.88, -8.09), (-9.51, 3.09), (9.51, 3.09), (-5.88, -8.09), (0.0, 10.0)],
        inners=[
            [(0.0, 6.5), (0.8, 5.5), (-0.8, 5.5), (0.0, 6.5)],
            [(5.5, 1.5), (6.2, 0.3), (4.8, 0.3), (5.5, 1.5)],
            [(-5.5, 1.5), (-4.8, 0.3), (-6.2, 0.3), (-5.5, 1.5)],
        ],
    ),
    # 外轮廓正常，但 inner 自交（洞本身是 bow-tie）✅（测你 inner 也要走 normalize）
    dict(
        outer=[(0, 0), (12, 0), (12, 12), (0, 12), (0, 0)],
        inners=[
            [(3, 3), (9, 9), (3, 9), (9, 3), (3, 3)],  # bow-tie hole
        ],
    ),
    # 外轮廓正常，但 inner 穿出 outer（洞越界）✅（测 step2 的 buffer(0)）
    dict(
        outer=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
        inners=[
            [(8, 8), (12, 8), (10, 11), (8, 8)],  # partly outside
        ],
    ),

    # 外轮廓自交拆成两瓣，但 某个洞跨越两瓣（最容易“修坏语义”的）✅
    dict(
        outer=[(0, 0), (10, 10), (0, 10), (10, 0), (0, 0)],  # bow-tie
        inners=[
            [(4.5, 4.5), (5.5, 4.5), (5.5, 5.5), (4.5, 5.5), (4.5, 4.5)],  # centered near intersection
        ],
    ),
    dict(
        outer=[(0, 0), (20, 0), (20, 20), (0, 20), (0, 0)],
        inners=[
            # 这条洞横贯整个外壳，等价于“切割带”，会把面分成上下两块
            [( -1, 9), (21, 9), (21, 11), (-1, 11), (-1, 9)],
        ],
    ),
    dict(
        outer=[(0, 0), (20, 0), (20, 20), (0, 20), (0, 0)],
        inners=[
            # 这条洞横贯整个外壳，等价于“切割带”，会把面分成上下两块
            [(-1, -1), (21, -1), (21, 21), (-1, 21), (-1, -1)],
        ],
    ),
]

MULTI_SIMPLE_CASES = {
    # --------------------------
    # ✅ 合法：多区域（互不相交）
    # --------------------------
    "valid_two_rects": {
        "desc": "两个分离矩形：标准合法 MultiPolygon",
        "outers": [
            [(0, 0), (10, 0), (10, 6), (0, 6), (0, 0)],
            [(20, 1), (28, 1), (28, 9), (20, 9), (20, 1)],
        ],
    },

    "valid_concave_and_triangle": {
        "desc": "一个凹多边形 + 一个三角形：都合法、单连通",
        "outers": [
            [(0, 0), (12, 0), (12, 3), (4, 3), (4, 10), (0, 10), (0, 0)],  # L 形凹多边形
            [(20, 0), (26, 0), (23, 7), (20, 0)],  # 三角形
        ],
    },

    "valid_nested_components": {
        "desc": "大方形内含小方形（注意：不是洞，是两个组件）=> 仍合法 MultiPolygon",
        "outers": [
            [(0, 0), (30, 0), (30, 30), (0, 30), (0, 0)],
            [(10, 10), (12, 10), (12, 12), (10, 12), (10, 10)],
        ],
    },

    # --------------------------
    # ⚠️ 边界：接触/重叠/未显式闭合
    # --------------------------
    "touching_at_a_point": {
        "desc": "两个多边形仅在一个点接触（拓扑边界情况，norm_geo 可能合并/也可能保持）",
        "outers": [
            [(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
            [(10, 10), (18, 10), (18, 18), (10, 18), (10, 10)],  # 只在 (10,10) 接触
        ],
    },

    "touching_along_edge": {
        "desc": "两个多边形共享一段边（可能被归一化为单个更大 polygon 或变成非法）",
        "outers": [
            [(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
            [(10, 0), (20, 0), (20, 10), (10, 10), (10, 0)],  # 与前一个共享 x=10 这条边
        ],
    },

    "overlapping_rects": {
        "desc": "两个矩形部分重叠（norm_geo 若做 union 可能合成一个 polygon；也可能报错）",
        "outers": [
            [(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],
            [(6, 6), (16, 6), (16, 16), (6, 16), (6, 6)],
        ],
    },

    "not_explicitly_closed": {
        "desc": "外环未显式闭合（缺最后一个回到起点）。Shapely 通常会自动闭合，但你可以测试是否会被 norm_geo 接受。",
        "outers": [
            [(0, 0), (10, 0), (10, 10), (0, 10)],  # 没有 (0,0)
            [(20, 0), (28, 0), (28, 8), (20, 8)],  # 没有 (20,0)
        ],
    },

    # --------------------------
    # ❌ 不合法：自交（八字/蝴蝶结）
    # --------------------------
    "invalid_bowtie": {
        "desc": "典型蝴蝶结自交（八字歧义）",
        "outers": [
            [(0, 0), (10, 10), (0, 10), (10, 0), (0, 0)],
        ],
    },

    "invalid_star_self_cross": {
        "desc": "星形自交（多处交叉）",
        "outers": [
            [(0, 6), (4, 6), (5, 0), (6, 6), (10, 6), (7, 9), (8, 14), (5, 11), (2, 14), (3, 9), (0, 6)],
        ],
    },

    # --------------------------
    # ❌ 不合法：点数不足 / 重合过多
    # --------------------------
    "invalid_too_few_points": {
        "desc": "点数不足（无法构成面）",
        "outers": [
            [(0, 0), (1, 1)],  # 两点
            [(10, 10), (12, 10), (10, 10)],  # 退化三点（其实只有两点）
        ],
    },

    "invalid_duplicate_points_heavy": {
        "desc": "大量重复点（某些实现会崩或产生零面积环）",
        "outers": [
            [(0, 0), (10, 0), (10, 0), (10, 10), (10, 10), (0, 10), (0, 10), (0, 0)],
        ],
    },

    # --------------------------
    # ❌ 不合法：退化零面积（共线/面积为0）
    # --------------------------
    "invalid_collinear": {
        "desc": "所有点共线（面积=0）",
        "outers": [
            [(0, 0), (5, 0), (10, 0), (0, 0)],
        ],
    },

    "invalid_almost_collinear_thin": {
        "desc": "极瘦近似共线（数值不稳定/可能被 norm_geo 认为是退化）",
        "outers": [
            [(0, 0), (1000, 0), (1000, 1e-9), (0, 1e-9), (0, 0)],
        ],
    },

    # --------------------------
    # ❌ 不合法：NaN / Inf 坐标
    # --------------------------
    "invalid_nan": {
        "desc": "含 NaN 坐标（应当直接非法）",
        "outers": [
            [(0, 0), (10, 0), (10, float('nan')), (0, 10), (0, 0)],
        ],
    },

    "invalid_inf": {
        "desc": "含 Inf 坐标（应当直接非法）",
        "outers": [
            [(0, 0), (10, 0), (10, float('inf')), (0, 10), (0, 0)],
        ],
    },

    # --------------------------
    # ❌ 不合法/高风险：几乎自交（交点靠得极近）
    # --------------------------
    "invalid_near_cross_epsilon": {
        "desc": "几乎在同一点交叉（浮点误差导致断裂/多段线/半边 polygonize 的常见来源）",
        "outers": [
            [(0, 0), (10, 10), (0, 10), (10, 0.0000001), (0, 0)],
        ],
    },
}
"""